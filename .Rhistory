loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaS:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
res.l
lambda1.grid
lambda1.grid <- seq(from=1e-5, to=1e-3, 10)
lambda1.grid
seq(from=1e-5, to=1e-3, 10)
seq(from=1e-5, to=1e-3, length=10)
lambda1.grid <- seq(from=1e-5, to=1e-3, length=10)
lambda2.grid <- seq(from=1e-5, to=1e-3, length=10)
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
res.l
res.l$res$W
apply(res.l$res$W, function(ww) (ww^2<1e-3))
apply(res.l$res$W, 2,function(ww) (ww^2<1e-3))
apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3))
sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))
cond <- sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0
cond
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0|pp==max(nb.arch.grid))
cond
cond <- TRUE
it <- 1
while(cond){
pp <- nb.arch.grid[it]
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
reslist[[it]] <- res.l
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0|pp==max(nb.arch.grid))
}
str(reslist)
cond <- TRUE
it <- 1
while(cond){
pp <- nb.arch.grid[it]
print(pp)
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
reslist[[it]] <- res.l
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0|pp==max(nb.arch.grid))
}
cond <- TRUE
it <- 1
while(cond){
pp <- nb.arch.grid[it]
print(pp)
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
reslist[[it]] <- res.l
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0|pp==max(nb.arch.grid))
it <- it+1
}
nb.arch.grid
pp
cond <- TRUE
it <- 1
pp <- nb.arch.grid[it]
while(cond){
print(pp)
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
reslist[[it]] <- res.l
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0|pp==max(nb.arch.grid))
it <- it+1
pp <- nb.arch.grid[it]
}
cond
it
pp
i=13
it=13
pp <- nb.arch.grid[it]
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0|pp==max(nb.arch.grid))
cond
pp
max(nb.arch.grid)
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0||pp==max(nb.arch.grid))
cond
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0&pp<max(nb.arch.grid))
cond
sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0
apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3))
res.l$res$W
rowSums(W)
rowSums(res.l$res$W)
str(res.l$res$Z1)
str(res.l$res$Z)
res.l$res$Z
res.l$res$Z1
res.l$res$Z2
reslist[[4]]
reslist[[4]]
reslist[[1]]
cond <- TRUE
it <- 1
pp <- nb.arch.grid[it]
pp
print(pp)
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
reslist[[it]] <- res.l
str(reslist[[1]])
stat
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
str(res)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
cond <- TRUE
it <- 1
pp <- nb.arch.grid[it]
while(cond){
print(pp)
BICp <- 1e8
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
reslist[[it]] <- res.l
it <- it+1
pp <- nb.arch.grid[it]
cond <- (sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0&pp<max(nb.arch.grid))
}
warnings()
reslist
sum(apply(res.l$res$Z, 2,function(ww) (sum(ww^2)<1e-3))
)
cond <- (sum(apply(res.l$res$Z, 2,function(ww) (sum(ww^2)<1e-3)))==0&sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0&pp<max(nb.arch.grid))
cond
cond <- TRUE
it <- 1
pp <- nb.arch.grid[it]
while(cond){
print(pp)
BICp <- 1e8
for(l1 in lambda1.grid){
if(stat=="C1C2"){
Y1 <- t(resSegmentation$Y1)
Y2 <- t(resSegmentation$Y2)
for(l2 in lambda2.grid){
res <- InCaSCN:::positive.fused(Y1,Y2, pp, lambda1 = l1, lambda2 = l2)
loss <- sum(((Y1+Y2)-(res$Y.hat$Y1+res$Y.hat$Y2))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum(((Y1+Y2)-rowMeans(Y1+Y2))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1, lamda2=l2), bkp=bkpList)
BICp <- BIC
}
}
}else{
Y <- t(resSegmentation$Y)
res <- InCaSCN:::positive.fused(Y, Y2=NULL, nb.arch=pp, lambda1 = l1)
loss <- sum((Y-(res$Y.hat$Y1))^2)
kZ <- sum(apply(res$Z, 2, diff)!=0)
BIC <-  n*pp*log(loss/(n*pp))+kZ*log(n*pp)
PVE <- 1-loss/(sum((Y-rowMeans(Y))^2))
if(BIC<BICp){
res.l <- list(BIC=BIC, PVE=PVE, res=res, param=list(nb.arch=pp, lambda1=l1), bkp=bkpList)
BICp <- BIC
}
}
}
reslist[[it]] <- res.l
it <- it+1
pp <- nb.arch.grid[it]
cond <- (sum(apply(res.l$res$Z, 2,function(ww) (sum(ww^2)<1e-3)))==0&sum(apply(res.l$res$W, 2,function(ww) (sum(ww^2)<1e-3)))==0&pp<max(nb.arch.grid))
}
reslist
reslist <- list()
library(InCaSCN)
dataAnnotTP <- loadCnRegionData(dataSet="GSE11976", tumorFrac=1)
dataAnnotN <- loadCnRegionData(dataSet="GSE11976", tumorFrac=0)
len <- 500*10
nbClones <- 3
bkps <- list(c(100,250)*10, c(150,400)*10,c(150,400)*10)
regions <-list(c("(0,3)", "(0,2)","(1,2)"), c("(1,1)", "(0,1)","(1,1)"), c("(0,2)", "(0,1)","(1,1)"))
datSubClone <- buildSubclones(len, dataAnnotTP, dataAnnotN, nbClones, bkps, regions)
M <- getWeightMatrix(100,0, 3, 15, sparse.coeff=0.7, contam.coeff=0.6, contam.max=2)
dat <- apply(M, 1, mixSubclones, subClones=datSubClone, fracN=NULL)
casRes <- InCaSCN(dat, stat="TCN")
str(casRes)
PVE <- sapply(casRes, function (cc) cc$PVE)
PVE
plot(sapply(casRes, function (cc) cc$param$nb.arch) , PVE)
casRes <- InCaSCN(dat, stat="TCN")
casRes <- InCaSCN(dat, stat="TCN")
plot(sapply(casRes, function (cc) cc$param$nb.arch) , PVE)
PVE
PVE <- sapply(casRes, function (cc) cc$PVE)
plot(sapply(casRes, function (cc) cc$param$nb.arch) , PVE)
casRes[[1]]
casRes[[6]]
casRes[[5]]
casResC1C2 <- InCaSCN(dat)
casResC1C2
PVEC1C2 <- sapply(casResC1C2, function (cc) cc$PVE)
plot(sapply(casResC1C2, function (cc) cc$param$nb.arch) , PVEC1C2, add=TRUE, pch=2)
plot(sapply(casResC1C2, function (cc) cc$param$nb.arch) , PVEC1C2, pch=2)
warnings(à)
warnings()
plot(sapply(casResC1C2, function (cc) cc$param$nb.arch) , PVEC1C2, pch=2)
points(sapply(casRes, function (cc) cc$param$nb.arch) , PVE, pch=1)
library(InCaSCN)
heatmap3(t(casResTCN[[idxBest]]$res$W)*100, showRowDendro = F, main="TCN",Colv=as.dendrogram(res.clustTCN))
library(heatmap3)
heatmap3(t(casRes[[idxBest]]$res$W)*100, showRowDendro = F, main="C1C2",Colv=as.dendrogram(res.clustC1C2))
load(file="dataProject.RData")
setwd("~/Documents/PhD/Teaching/ENSIIE/2015-2016/TP/")
load(file="dataProject.RData")
gl <- glm(abs~Age, family=poisson, data=data)
summary(gl)
exp(predict(gl, data.frame(Age=10)))
1.89977+-0.06370*10
predict(gl, data.frame(Age=10))
str(data)
by(data$abs, data$Age, mean)
predict.glm(gl, data.frame(Age=10))
args(predict.glm)
predict.glm(gl, data.frame(Age=10))
exp(predict.glm(gl, data.frame(Age=10)))
gl$coefficients
gl$coefficients[1]+gl$coefficients[2]*10
exp(gl$coefficients[1]+gl$coefficients[2]*10)
exp(predict.glm(gl, data.frame(Age=10)))
by(data$abs, data$Age, mean)
getwd()
setwd("~/Documents/PhD/Teaching/ENSIIE/2015-2016/TP/")
load(file="dataProject.RData")
AbsF <- data$abs[which(data$Sex=="F")]
AbsG <- data$abs[which(data$Sex=="G")]
t.test(AbsF, AbsG)
var.test(AbsF, AbsG)
t.test(AbsF, AbsG, var.equal = T)
var.test(AbsUpper6, AbsLess6)
AbsUpper6 <- data$abs[which(data$Age>9)]
AbsLess6 <- data$abs[which(data$Age<=9)]
var.test(AbsUpper6, AbsLess6)
t.test(AbsLess6, AbsUpper6)
t.test(AbsLess6, AbsUpper6, var.test=T)
X <- seq(data$abs)
V <- function(lambda) { ## Vraisemblance de l’échantillon
prod(dpois(data$abs,lambda)) }
LV <- function(lambda) { ## Log-Vraisemblance de l’échantillon
sum(log(dpois(data$abs,lambda))) }
lambda=seq(0,11,by=0.01);
MV=lambda
for(i in 0 :length(lambda)){ MV[i]=LV(lambda[i])}
plot(lambda,MV,type="l",col="blue", main="Log-Vraisemblance de l’échantillon")
plot(2:6,MV,type="l",col="blue", main="Log-Vraisemblance de l’échantillon")
plot(2:6,LV[2:6],type="l",col="blue", main="Log-Vraisemblance de l’échantillon")
plot(2:6,sapply(2:6, LV),type="l",col="blue", main="Log-Vraisemblance de l’échantillon")
qt(0.95,df=n-1)
n <- 150
n <- 150
qt(0.95,df=n-1)
qt(0.975,df=n-1)
q1=qnorm(0.025)
q1
iq <- qnorm(0.975,df=n-1)*sqrt(muHat/n)
iq <- qnorm(0.975)*sqrt(muHat/n)
d
iq <- qnorm(0.975)*sqrt(muHat/n)
IC.sup <- muHat+ iq
IC.inf <- muHat- iq
muHat <- mean(data$abs)
iq <- qnorm(0.975)*sqrt(muHat/n)
IC.sup <- muHat+ iq
IC.inf <- muHat- iq
IC.sup
IC.sup
iq
IC.sup <- muHat+ iq
IC.inf <- muHat- iq
IC.inf
IC.sup
iq <- qt(0.975, n-1)*sqrt(muHat/n)
IC.sup <- muHat+ iq
IC.inf <- muHat- iq
IC.inf
IC.sup
