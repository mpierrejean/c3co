{
    "collab_server" : "",
    "contents" : "#' Positive fused lasso function\n#'\n#' @param Y1 A matrix containing the segmented minor copy number (\\code{n} patients in row and \\code{L} segments in columns)\n#' @param Y2 A matrix containing the segmented major copy number (\\code{n} patients in row and \\code{L} segments in columns)\n#' @param nb.arch An integer which is the number of archetypes in the model\n#' @param lambda1 A real number which is the penalty coefficient for the fused lasso on the minor copy number dimension\n#' @param lambda2 A real number which is the penalty coefficient for the fused lasso on the major copy number dimension\n#' @return The list of archetypes (\\code{Z} the total copy number matrix,\\code{Z1} the minor copy number matrix and \\code{Z2} the major copy number matrix), matrix weight \\code{W} and the reconstructed minor and major copy numbers.\n#' @examples\n#' dataAnnotTP <- loadCnRegionData(dataSet=\"GSE11976\", tumorFrac=1)\n#' dataAnnotN <- loadCnRegionData(dataSet=\"GSE11976\", tumorFrac=0)\n#' len <- 500*10\n#' nbClones <- 3\n#' bkps <- list(c(100,250)*10, c(150,400)*10,c(150,400)*10)\n#' regions <-list(c(\"(0,3)\", \"(0,2)\",\"(1,2)\"), c(\"(1,1)\", \"(0,1)\",\"(1,1)\"), c(\"(0,2)\", \"(0,1)\",\"(1,1)\"))\n#' datSubClone <- buildSubclones(len, dataAnnotTP, dataAnnotN, nbClones, bkps, regions)\n#' M = matrix(c(40,30, 0,0,70, 15,10, 0, 35,15,0,0 ,0,0,0), byrow=TRUE, ncol=3)\n#' simu <- apply(M, 1, mixSubclones, subClones=datSubClone, fracN=NULL)\n#' YTCNtoSeg <- t(sapply(simu, function(cc) cc$tcn))\n#' YDHtoSeg <- t(sapply(simu, function(cc) cc$dh))\n#' sim <- t(rbind(YTCNtoSeg,YDHtoSeg))\n#' res <- jointSeg(sim, method = \"RBS\", K=8)\n#' bkp <- res$bestBkp\n#' Y1 <- t(sapply(simu, function(cc) cc$c1))\n#' Y2 <-  t(sapply(simu, function(cc) cc$c2))\n#' Y1seg <- t(apply(Y1, 1, binMeans, x=1:ncol(Y1),bx= c(1,bkp,ncol(Y1)), na.rm=TRUE))\n#' Y2seg <- t(apply(Y2, 1, binMeans, x=1:ncol(Y1),bx= c(1,bkp,ncol(Y1)), na.rm=TRUE))\n#' lambda <- 1e-5\n#' rC1C2 <- InCaSCN:::positive.fused(Y1seg,Y2seg, 4,lambda1 = lambda, lambda2 = lambda)\n#' rTCN <- InCaSCN:::positive.fused(Y1seg+Y2seg,NULL, 4,lambda1 = lambda, lambda2 = lambda)\npositive.fused <- function(Y1, Y2, nb.arch, lambda1, lambda2,\n                           eps = 1e-2, max.iter = 50, verbose=F) {\n\n    ## problem dimensions\n    n <- nrow(Y1) # number of individuals\n    L <- ncol(Y1) # number of loci\n\n    ## _______________________________________________________\n    ## STEP 0: INITIALIZATION\n    ## Under recommandations of NMF and Archetypal analysis random initialization to find the global minimum.\n    if(is.null(Y2)){\n      Y=Y1\n    }else{\n      Y=Y1+Y2\n    }\n    ## initializing Z by clustering on PCA\n      cluster <- HCPC(PCA(Y, graph=FALSE), nb.clust=nb.arch, graph=FALSE)$data.clust$clust\n\n      ## averaging the Y over the clusters to initialize the archetypes\n      Z1.init <- sapply(split(as.data.frame(Y1), cluster), colMeans)\n      if(!is.null(Y2)){\n        Z2.init <- sapply(split(as.data.frame(Y2), cluster), colMeans)\n      }else{\n        Z2.init <- NULL\n      }\n      Z <- list(Z1 = Z1.init, Z2 = Z2.init)\n\n      ## main loop for alternate optimization\n      iter <- 0\n      cond <- FALSE\n      delta <- Inf\n      min.loss <- 1e5\n      while(!cond) {\n          iter <- iter + 1\n          if(verbose) cat(\"\\niter number \",iter)\n          ## __________________________________________________\n          ## STEP 1: optimize over W (fixed Z1, Z2)\n          W <- get.W(rbind(Z$Z1,Z$Z2), cbind(Y1,Y2))\n          ## __________________________________________________\n          ## STEP 2: optimize over Z (fixed W)\n          Z <- get.Z(W, Y1, Y2, lambda1, lambda2)\n          ## __________________________________________________\n          ## STEP 3: check for convergence of the weights\n          if (iter>1) {delta <- sqrt(sum((W-W.old)^2))}\n\n          cond <- (iter > max.iter | delta < eps)\n\n          if(verbose) cat(\"\\ndelta =\",round(delta, 4))\n          W.old <- W\n      }\n      if(!is.null(Y2)){\n        loss <- (sum((Y1-W %*% t(Z$Z1))^2)+sum((Y2-W %*% t(Z$Z2))^2))/(n*L)\n      }else{\n        loss <- (sum((Y1-W %*% t(Z$Z1))^2))/(n*L)\n      }\n      if(loss<min.loss){\n        if(!is.null(Y2)){\n          res <- list(Z=Z$Z1+Z$Z2, Z1=Z$Z1, Z2=Z$Z2, W=W, Y.hat=list(Y1 = W %*% t(Z$Z1), Y2 = W %*% t(Z$Z2)))\n        }else{\n          res <- list(Z=Z$Z1, Z1=Z$Z1, Z2=Z$Z2, W=W, Y.hat=list(Y1 = W %*% t(Z$Z1), Y2 = NULL))\n        }\n        min.loss <- loss\n      }\n      if(verbose) cat(\"\\nDONE!\\n\")\n\n    return(res)\n}\n",
    "created" : 1462970247700.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "157650010",
    "id" : "91FD3A96",
    "lastKnownWriteTime" : 1462796260,
    "last_content_update" : 1462796260,
    "path" : "~/Documents/PhD/jointSeg/dev/archetypesC1C2/package/InCaSCN/R/positiveFusedLasso.R",
    "project_path" : "R/positiveFusedLasso.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}