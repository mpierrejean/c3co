---
title: "c3co"
author: "Morgane Pierre-Jean and Pierre Neuvial"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
---

## Introduction

This document provides a brief tutorial on using the c3co package, which implements a constraint dictionary learning problem to recover subclones across several patients with SNP data. The c3co model is designed to identify regions of copy number variation (CNV) in multi-sample SNPs data. In particular, it takes advantage of any
similarities shared among samples while maintaining the ability to identify any potential heterogeneity by using parental copy number signals. The model is decribed in details below

## Model 

The figure below illustrates the model used in the InCaS-CN package. Two heterogeneous tumor samples (green and yellow circles) are composed of a collection of normal cells (gray discs) and two cancer subclones (red triangles and blue squares). One of the cancer subclones is present in both tumor samples. 

![](img/features.png)
![](img/features2.png)

The corresponding (noiseless) copy number profiles are displayed in the figure below. They are given by a linear combination of the latent profiles. This Figure is adapted from \cite{nowak2011fused}. [REF]

![](img/model.png)
![](img/model2.png)


## Using the package
```{r, echo=F, message=FALSE,warning=FALSE}
stopifnot(packageVersion("acnr") >= '0.2.6')
library("c3co")
library("ggplot2")
set.seed(10)
```

### Creating a synthetic data set

We start by defining the characteristics of the subclone profiles: length, number of subclones, breakpoint positions, and copy number states:

```{r}
len <- 500*10
nbClones <- 3
bkps <- list(c(100,250)*10, c(150,400)*10,c(150,400)*10)
regions <-list(c("(0,1)", "(0,2)","(1,2)"), c("(1,1)", "(0,1)","(1,1)"), c("(0,2)", "(0,1)","(1,1)"))
```

Then, we load an annotated data set from the `acnr` package [REF].  The `buildSubclones` function can then be used to generate the subclone profiles with the above characteristics, by resampling from the annotated data set.

```{r}
dataAnnotTP <- acnr::loadCnRegionData(dataSet="GSE11976", tumorFrac=1)
dataAnnotN <- acnr::loadCnRegionData(dataSet="GSE11976", tumorFrac=0)
datSubClone <- buildSubclones(len, dataAnnotTP, dataAnnotN, nbClones, bkps, regions)
```
 
The same can be done using another data set from the `acnr` package:

 
```{r}
dataAnnotTP <- acnr::loadCnRegionData(dataSet="GSE13372", tumorFraction=1)
dataAnnotN <- acnr::loadCnRegionData(dataSet="GSE13372", tumorFraction=0)
datSubClone2 <- buildSubclones(len, dataAnnotTP, dataAnnotN, nbClones, bkps, regions)
```

```{r, echo=FALSE}
cols <- c("#00000033", "#FD6C9E33", "#00000033")
plot(datSubClone[[1]]$ct, col=cols[factor(datSubClone[[1]]$genotype)], cex=0.3, pch=19, ylab="TCN",ylim=c(0,4))
plot(datSubClone2[[1]]$ct, col=cols[factor(datSubClone2[[1]]$genotype)], cex=0.3, pch=19, ylab="TCN",ylim=c(0,4))
plot(datSubClone[[1]]$baft, col=cols[factor(datSubClone[[1]]$genotype)], cex=0.3, pch=19, ylab="BAF",ylim=c(-0.1,1.1))
plot(datSubClone2[[1]]$baft, col=cols[factor(datSubClone2[[1]]$genotype)], cex=0.3, pch=19, ylab="BAF",ylim=c(-0.1,1.1))
```

Once subclones are created, we can generate a matrix $W$ in order to build mixtures.

```{r, warning=FALSE, cache=FALSE}
W = getWeightMatrix(70,30, nb.arch = 3, nb.samp = 20)
dat <- apply(W, 1, mixSubclones, subClones=datSubClone, fracN=NULL)
str(dat[[1]])
```

Note that dat is a list of data frame with the following necessary columns : ```c1,c2,tcn,dh,genotype```

### Run c3co model

Then the c3co method can be appluied to the mixture data set. Let us choose the same grid for $\lambda_1$ and $\lambda_2$ and a grid from 2 to 6 for the number of subclones.

```{r c3co, warning=FALSE}
lambda1.grid <- lambda2.grid <- c(0.005,0.001)
casRes <- c3co(dat,lambda1.grid, lambda2.grid, nb.arch.grid = 2:6)
casResTCN <- c3co(dat,lambda1.grid, lambda2.grid, nb.arch.grid = 2:6, stat="TCN")
```

For each $p$ ```c3co``` keep only the combination $(\lambda_1, \lambda_2)$ which minimize the BIC. The next step is to choose the best $p$ (number of subclones). In this example, it seems that the best is $\hat{p}=4$ (which is the true number of subclones).

```{r}
result.pve <- sapply(casRes, function(cc) cc$PVE)
dataPVE <- data.frame(nb.subclones=sapply(casRes, function(cc) cc$param$nb.arch), pve=result.pve)
ggplot(dataPVE)+geom_line(aes(nb.subclones, pve))+geom_point(aes(nb.subclones, pve))+xlab("Number of subclones")+ylab("PVE")+ylim(c(0.8,1))+theme_bw()
```
```{r}
result.pveTCN <- sapply(casResTCN, function(cc) cc$PVE)
dataPVETCN <- data.frame(nb.subclones=sapply(casResTCN, function(cc) cc$param$nb.arch), pve=result.pveTCN)
ggplot(dataPVETCN)+geom_line(aes(nb.subclones, pve))+geom_point(aes(nb.subclones, pve))+xlab("Number of subclones")+ylab("PVE")+ylim(c(0.8,1))+theme_bw()
```

We can compare the true and the estimated matrices of the weights. Even if the computation is not perfect, we can easily recover a classification close to the truth with the inferred weight matrix. 

```{r heatmap_C1C2, fig.width=7, fig.height=5}
idxBestC1C2 <- min(which(diff(result.pve)<1e-1))+1
idxBestTCN <- min(which(diff(result.pveTCN)<1e-1))+1
str(casRes[[idxBestC1C2]])
res.clustTRUE = hclust(dist(cbind(W, 100-rowSums(W))),method="ward.D")
library("RColorBrewer")
col = colorRampPalette(brewer.pal(9, 'GnBu'))(100)
Wplot(casRes[[idxBestC1C2]])
```
```{r heatmap_TCN, fig.width=7, fig.height=5}
Wplot(casResTCN[[idxBestTCN]])
```
```{r heatmap_TRUE, fig.width=7, fig.height=5}
heatmap.3(cbind(W, 100-rowSums(W)), dendrogram="row", main="TRUE",Rowv=as.dendrogram(res.clustTRUE), col=col,scale="none")
```


If we look at the subclones in the dimension of parental copy numbers, we can recover the simulated alterations.

```{r,echo=FALSE}
if(length(casRes[[idxBestC1C2]]$idxNA)>0){
  bkp <- c(1,casRes[[idxBestC1C2]]$bkp[-casRes[[idxBestC1C2]]$idxNA])
}else{
  bkp <- c(1,casRes[[idxBestC1C2]]$bkp[[1]])
}
```
```{r,Z1Z2hat, fig.width=5, fig.height=5}
z1 <- rbind(casRes[[idxBestC1C2]]$res$Z1,casRes[[idxBestC1C2]]$res$Z1[length(bkp),])
z2 <- rbind(casRes[[idxBestC1C2]]$res$Z2,casRes[[idxBestC1C2]]$res$Z2[length(bkp),])
dfZ <- data.frame(Cn=c(as.numeric(z1),as.numeric(z2)),stat=factor(rep(c("Minor", "Major"), each = prod(dim(z1))), levels=c("Minor", "Major")), bkps=rep(c(bkp,len), 2), latent=as.factor(rep(rep(1:ncol(z1), each=nrow(z1)), times=2)))
gC <- ggplot(dfZ, aes(y=Cn, x=bkps))+geom_step(aes(col=latent), direction="hv")+ facet_wrap(~stat, ncol=1, scale="free")+theme_bw()+xlab("Genome Position")+scale_colour_discrete("Latent\nProfile")+ylab("Copy number")
gC
```
