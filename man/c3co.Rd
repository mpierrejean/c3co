% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/c3co.R
\name{c3co}
\alias{c3co}
\title{Cancer subclone Inference function}
\usage{
c3co(dat, lambda1.grid = NULL, lambda2.grid = NULL,
  nb.arch.grid = 2:(length(dat) - 1), stat = "C1C2",
  output.dir = "results_c3co", segment = TRUE, forceSeg = FALSE,
  forceInferrence = FALSE, init.random = FALSE, new.getZ = TRUE)
}
\arguments{
\item{lambda1.grid, }{lambda2.grid A grid of real numbers which is the penalty coefficients for the fused lasso on the minor and major copy number dimension}

\item{nb.arch.grid}{A vector of integers which is the number of archetypes in the model}

\item{stat}{TCN or C1C2}

\item{output.dir}{directory to save segmentation and feature data}

\item{segment}{By defaut \code{TRUE} (segment data before inferring features)}

\item{forceSeg}{\code{TRUE} of \code{FALSE} by default \code{FALSE} if \code{fileSeg="segData.rds"} already exists in \code{output.dir}}

\item{forceInferrence}{\code{TRUE} of \code{FALSE} by default \code{FALSE} if \code{fileFeat=featureData,p=p.rds} already exists in \code{output.dir}}

\item{init.random}{\code{TRUE} or \code{FALSE} by defaut \code{FALSE}. Initialization done by clustering}

\item{new.getZ}{\code{TRUE} if you want to parallelize inferrence of Minor and Major copy numbers (TRUE by default)}
}
\value{
A list of archetypes (\code{Z} the total copy number matrix,\code{Z1} the minor copy number matrix and \code{Z2} the major copy number matrix), matrix weight \code{W} and the reconstructed minor and major copy numbers.
}
\description{
Cancer subclone Inference function
}
\examples{
dataAnnotTP <- acnr::loadCnRegionData(dataSet="GSE11976", tumorFrac=1)
dataAnnotN <- acnr::loadCnRegionData(dataSet="GSE11976", tumorFrac=0)
len <- 500*10
nbClones <- 3
bkps <- list(c(100,250)*10, c(150,400)*10,c(150,400)*10)
regions <-list(c("(0,3)", "(0,2)","(1,2)"), 
c("(1,1)", "(0,1)","(1,1)"), c("(0,2)", "(0,1)","(1,1)"))
datSubClone <- buildSubclones(len, dataAnnotTP, dataAnnotN, nbClones, bkps, regions)
M <- getWeightMatrix(100,0, 3, 15, sparse.coeff=0.7, contam.coeff=0.6, contam.max=2)
dat <- apply(M, 1, mixSubclones, subClones=datSubClone, fracN=NULL)
l1 <- seq(from=1e-6, to=1e-5, length=3)
l2 <- seq(from=1e-6, to=1e-5, length=3)
system.time(casResC1C2 <- c3co(dat, lambda1.grid=l1, lambda2.grid=l2, nb.arch.grid=2:6))
casRes <- c3co(dat, stat="TCN", lambda1.grid=l1, lambda2.grid=l2, nb.arch.grid=2:6)
}

